{"version":3,"file":"vendor-dnd-core.js","mappings":"wJAyBW,SAASA,EAASC,GACzB,MAAwB,iBAAVA,CAClB,CC3BO,MAAMC,EAAc,uBACdC,EAAa,sBACbC,EAAsB,+BACtBC,EAAQ,iBACRC,EAAO,gBACPC,EAAW,oBCJjB,SAASC,EAAgBC,EAAcC,GAC1C,MAAO,CACHC,KAAMT,EACNU,QAAS,CACLF,mBAAoBA,GAAsB,KAC1CD,aAAcA,GAAgB,MAG1C,CCLA,MAAMI,EAAyB,CAC3BF,KAAMT,EACNU,QAAS,CACLH,aAAc,KACdC,mBAAoB,OAGrB,SAASI,EAAgBC,GAC5B,OAAO,SAAmBC,EAAY,GAAIC,EAAU,CAChDC,eAAe,IAEf,MAAM,cAAEA,GAAe,EAAK,aAAET,EAAa,sBAAEU,GAA6BF,EACpEG,EAAUL,EAAQM,aAClBC,EAAWP,EAAQQ,cAEzBR,EAAQS,SAAShB,EAAgBC,IAyCzC,SAA0BO,EAAWI,EAASE,IAC1C,QAAWF,EAAQK,aAAc,yCACjCT,EAAUU,SAAQ,SAASC,IACvB,OAAUL,EAASM,UAAUD,GAAW,uCAC5C,GACJ,CA7CQE,CAAiBb,EAAWI,EAASE,GAErC,MAAMK,EAkDd,SAA4BX,EAAWI,GACnC,IAAIO,EAAW,KACf,IAAI,IAAIG,EAAId,EAAUe,OAAS,EAAGD,GAAK,EAAGA,IACtC,GAAIV,EAAQY,cAAchB,EAAUc,IAAK,CACrCH,EAAWX,EAAUc,GACrB,KACJ,CAEJ,OAAOH,CACX,CA3DyBM,CAAmBjB,EAAWI,GAC/C,GAAgB,MAAZO,EAEA,YADAZ,EAAQS,SAASX,GAIrB,IAAIH,EAAqB,KACzB,GAAID,EAAc,CACd,IAAKU,EACD,MAAM,IAAIe,MAAM,0CAmChC,SAA+Cf,IAC3C,OAA2C,mBAA1BA,EAAsC,2EAC3D,CAnCYgB,CAAsChB,GACtCT,EAAqBS,EAAsBQ,EAC/C,CAEAZ,EAAQS,SAAShB,EAAgBC,EAAcC,IAC/C,MACM0B,EADSd,EAASM,UAAUD,GACdU,UAAUjB,EAASO,GAEvC,GAAY,MAARS,EACA,QA2BZ,SAA4BA,IACxB,OAAUpC,EAASoC,GAAO,0BAC9B,CA3BQE,CAAmBF,GACnBd,EAASiB,UAAUZ,GACnB,MAAMa,EAAWlB,EAASmB,cAAcd,GACxC,MAAO,CACHhB,KAAMR,EACNS,QAAS,CACL4B,WACAJ,OACAT,WACAlB,aAAcA,GAAgB,KAC9BC,mBAAoBA,GAAsB,KAC1CgC,iBAAkBxB,GAG9B,CACJ,CC3DA,SAASyB,EAAgBC,EAAKC,EAAKC,GAW/B,OAVID,KAAOD,EACPG,OAAOC,eAAeJ,EAAKC,EAAK,CAC5BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdP,EAAIC,GAAOC,EAERF,CACX,CACA,SAASQ,EAAcC,GACnB,IAAI,IAAIvB,EAAI,EAAGA,EAAIwB,UAAUvB,OAAQD,IAAI,CACrC,IAAIyB,EAAyB,MAAhBD,UAAUxB,GAAawB,UAAUxB,GAAK,CAAC,EAChD0B,EAAUT,OAAOU,KAAKF,GACkB,mBAAjCR,OAAOW,wBACdF,EAAUA,EAAQG,OAAOZ,OAAOW,sBAAsBH,GAAQK,QAAO,SAASC,GAC1E,OAAOd,OAAOe,yBAAyBP,EAAQM,GAAKZ,UACxD,MAEJO,EAAQ9B,SAAQ,SAASmB,GACrBF,EAAgBU,EAAQR,EAAKU,EAAOV,GACxC,GACJ,CACA,OAAOQ,CACX,CAIO,SAASU,EAAWhD,GACvB,OAAO,SAAcE,EAAU,CAAC,GAC5B,MAAMG,EAAUL,EAAQM,aAClBC,EAAWP,EAAQQ,eAgBjC,SAA0BH,IACtB,OAAUA,EAAQK,aAAc,yCAChC,QAAWL,EAAQ4C,UAAW,oDAClC,CAlBQ,CAAiB5C,GACjB,MAAM6C,EA8Bd,SAA6B7C,GACzB,MAAM6C,EAAY7C,EAAQ8C,eAAeN,OAAOxC,EAAQ+C,gBAAiB/C,GAEzE,OADA6C,EAAUG,UACHH,CACX,CAlC0BI,CAAoBjD,GAEtC6C,EAAUvC,SAAQ,CAAC4C,EAAUC,KACzB,MAAMC,EAelB,SAA6BF,EAAUC,EAAOjD,EAAUF,GACpD,MAAMiC,EAAS/B,EAASmD,UAAUH,GAClC,IAAIE,EAAanB,EAASA,EAAOqB,KAAKtD,EAASkD,QAAYK,EAK3D,OAEJ,SAA8BH,IAC1B,YAAgC,IAAfA,GAA8BxE,EAASwE,GAAa,qDACzE,CARII,CAAqBJ,QACK,IAAfA,IACPA,EAAuB,IAAVD,EAAc,CAAC,EAAInD,EAAQyD,iBAErCL,CACX,CAvB+BM,CAAoBR,EAAUC,EAAOjD,EAAUF,GAC5D2D,EAAS,CACXpE,KAAML,EACNM,QAAS,CACL4D,WAAYpB,EAAc,CAAC,EAAGnC,EAASuD,KAG/CzD,EAAQS,SAASuD,EAAO,GAEhC,CACJ,CC/CO,SAASC,EAAcjE,GAC1B,OAAO,WACH,MAAMK,EAAUL,EAAQM,aAClBC,EAAWP,EAAQQ,eAajC,SAA0BH,IACtB,OAAUA,EAAQK,aAAc,0CACpC,CAdQwD,CAAiB7D,GACjB,MAAMO,EAAWP,EAAQ8D,cAMzB,OALgB,MAAZvD,IACeL,EAASM,UAAUD,GAAU,GACrCwD,QAAQ/D,EAASO,GACxBL,EAAS8D,eAEN,CACHzE,KAAMJ,EAEd,CACJ,CCjBO,SAAS8E,EAAYC,EAAYC,GACpC,OAAwB,OAApBA,EACsB,OAAfD,EAEJE,MAAMC,QAAQH,GAAcA,EAAWI,MAAMC,GAAIA,IAAMJ,IAC1DD,IAAeC,CACvB,CCHO,SAASK,EAAY7E,GACxB,OAAO,SAAe8E,GAAc,aAAEpF,GAAkB,CAAC,IAkB7D,SAAgCoF,IAC5B,OAAUL,MAAMC,QAAQI,GAAe,qCAC3C,CAnBQC,CAAuBD,GACvB,MAAM5B,EAAY4B,EAAaE,MAAM,GAC/B3E,EAAUL,EAAQM,aAClBC,EAAWP,EAAQQ,cAKzB,OAsBR,SAAoC0C,EAAW3C,EAAUiE,GAIrD,IAAI,IAAIzD,EAAImC,EAAUlC,OAAS,EAAGD,GAAK,EAAGA,IAAI,CAC1C,MAAMwC,EAAWL,EAAUnC,GAEtBuD,EADc/D,EAAS0E,cAAc1B,GACbiB,IACzBtB,EAAUgC,OAAOnE,EAAG,EAE5B,CACJ,CApCQoE,CAA2BjC,EAAW3C,EADdF,EAAQ+E,eAgBxC,SAAyBlC,EAAW7C,EAASE,IACzC,OAAUF,EAAQK,aAAc,0CAChC,QAAWL,EAAQ4C,UAAW,iCAC9B,IAAI,IAAIlC,EAAI,EAAGA,EAAImC,EAAUlC,OAAQD,IAAI,CACrC,MAAMwC,EAAWL,EAAUnC,IAC3B,OAAUmC,EAAUmC,YAAY9B,KAAcxC,EAAG,wDACjD,MAAMuB,EAAS/B,EAASmD,UAAUH,IAClC,OAAUjB,EAAQ,uCACtB,CACJ,CAvBQgD,CAAgBpC,EAAW7C,EAASE,GAoC5C,SAAyB2C,EAAW7C,EAASE,GAEzC2C,EAAUvC,SAAQ,SAAS4C,GACRhD,EAASmD,UAAUH,GAC3BgC,MAAMlF,EAASkD,EAC1B,GACJ,CAzCQiC,CAAgBtC,EAAW7C,EAASE,GAC7B,CACHX,KAAMN,EACNO,QAAS,CACLqD,YACAxD,aAAcA,GAAgB,MAG1C,CACJ,CCpBO,SAAS+F,EAAwBzF,GACpC,OAAO,WAEH,GADgBA,EAAQM,aACZI,aACR,MAAO,CACHd,KAAMP,EAIlB,CACJ,CCVO,MAAMqG,EACT,cAAAC,CAAeC,GACXC,KAAKD,QAAUA,CACnB,CACA,UAAAtF,GACI,OAAOuF,KAAKxF,OAChB,CACA,UAAAyF,GACI,OAAOD,KAAKD,OAChB,CACA,WAAApF,GACI,OAAOqF,KAAKxF,QAAQE,QACxB,CACA,UAAAwF,GACoE,MAAM/F,EAAU6F,MAC1E,SAAEpF,GAAcoF,KAAKG,MASrBC,ECnBP,SAA+BjG,GAClC,MAAO,CACHsB,UAAWvB,EAAgBC,GAC3BkG,kBAAmBT,EAAwBzF,GAC3CuF,MAAOV,EAAY7E,GACnB2D,KAAMX,EAAWhD,GACjBoE,QAASH,EAAcjE,GAE/B,CDWwBmG,CAAsBN,MACtC,OAAO7D,OAAOU,KAAKuD,GAASG,QAAO,CAACC,EAAcvE,KAC9C,MAAMkC,EAASiC,EAAQnE,GAV3B,IAA2BwE,EAYvB,OADAD,EAAavE,IAXUwE,EAWetC,EAV/B,IAAIuC,KACP,MAAMvC,EAASsC,EAAcE,MAAMxG,EAASuG,QACtB,IAAXvC,GACPvD,EAASuD,EACb,GAOGqC,CAAY,GACpB,CAAC,EACR,CACA,QAAA5F,CAASuD,GACL6B,KAAKG,MAAMvF,SAASuD,EACxB,CACA,WAAAyC,CAAYT,EAAO3F,GACfwF,KAAKa,SAAU,EACfb,KAAKc,qBAAuB,KACxB,MAAMC,EAAcf,KAAKG,MAAMa,WAAWC,SAAW,EACjDjB,KAAKD,UACDgB,IAAgBf,KAAKa,SACrBb,KAAKD,QAAQmB,QACblB,KAAKa,SAAU,IACPE,GAAef,KAAKa,UAC5Bb,KAAKD,QAAQoB,WACbnB,KAAKa,SAAU,GAEvB,EAEJb,KAAKG,MAAQA,EACbH,KAAKxF,QAAUA,EACf2F,EAAMiB,UAAUpB,KAAKc,qBACzB,EEtCO,SAASO,EAASC,EAAGC,GAC5B,MAAO,CACHC,EAAGF,EAAEE,EAAID,EAAEC,EACXC,EAAGH,EAAEG,EAAIF,EAAEE,EAEnB,CClBO,MAAMC,EAAO,GACPC,EAAM,GACnBD,EAAKE,aAAc,EACnBD,EAAIE,YAAa,ECAV,MAAMC,EACT,sBAAAC,CAAuBC,EAAU3H,EAAU,CAAC,GACxC,MAAM,WAAE4H,GAAgB5H,GACxB,OAA8B,mBAAb2H,EAAyB,iCAC1C,YAAgC,IAAfC,GAA8BrD,MAAMC,QAAQoD,GAAa,4DAC1E,IAAIC,EAAclC,KAAKG,MAAMa,WAAWmB,QAaxC,OAAOnC,KAAKG,MAAMiB,WAZG,KACjB,MAAMgB,EAAQpC,KAAKG,MAAMa,WACnBqB,EAAiBD,EAAMD,QAC7B,IACI,MAAMG,EAAkBD,IAAmBH,GAAeG,IAAmBH,EAAc,IDJhG,SAAkBK,EAAUN,GACnC,OAAIM,IAAab,IAGba,IAAaZ,QAA6B,IAAfM,IZqCMO,EYlCMD,EAAZN,EZmCjBjF,QAAQ+B,GAAIyD,EAAOC,QAAQ1D,IAAM,KYlC9B5D,OAAS,GZiCnB,IAA8BqH,CYhCzC,CCLiHE,CAASN,EAAMO,gBAAiBV,GAC5HK,GACDN,GAER,CAAE,QACEE,EAAcG,CAClB,IAGR,CACA,uBAAAO,CAAwBZ,IACpB,OAA8B,mBAAbA,EAAyB,gCAC1C,IAAIa,EAAgB7C,KAAKG,MAAMa,WAAW8B,WAS1C,OAAO9C,KAAKG,MAAMiB,WARG,KACjB,MAAM2B,EAAY/C,KAAKG,MAAMa,WAAW8B,WACpCC,IAAcF,IAGlBA,EAAgBE,EAChBf,IAAU,GAGlB,CACA,aAAA5G,CAAcL,GACV,IAAKA,EACD,OAAO,EAEX,MAAM4B,EAASqD,KAAKtF,SAASM,UAAUD,GAEvC,OADA,OAAU4B,EAAQ,6CAA6C5B,MAC3DiF,KAAKnF,cAGF8B,EAAOqG,QAAQhD,KAAMjF,EAChC,CACA,eAAAwC,CAAgBG,GAEZ,IAAKA,EACD,OAAO,EAEX,MAAMjB,EAASuD,KAAKtF,SAASmD,UAAUH,GAEvC,OADA,OAAUjB,EAAQ,6CAA6CiB,QAC1DsC,KAAKnF,cAAgBmF,KAAK5C,aAKxBqB,EAFYuB,KAAKtF,SAAS0E,cAAc1B,GACvBsC,KAAKT,gBACsB9C,EAAOwG,QAAQjD,KAAMtC,GAC5E,CACA,UAAA7C,GACI,OAAOqI,QAAQlD,KAAKT,cACxB,CACA,gBAAA4D,CAAiBpI,GAEb,IAAKA,EACD,OAAO,EAEX,MAAM4B,EAASqD,KAAKtF,SAASM,UAAUD,GAAU,GAEjD,OADA,OAAU4B,EAAQ,6CAA6C5B,QAC1DiF,KAAKnF,eAAiBmF,KAAKlE,oBAGbkE,KAAKtF,SAASmB,cAAcd,KACvBiF,KAAKT,eAItB5C,EAAO9B,WAAWmF,KAAMjF,GACnC,CACA,YAAAqI,CAAa1F,EAAUrD,EAAU,CAC7BgJ,SAAS,IAGT,IAAK3F,EACD,OAAO,EAEX,MAAM,QAAE2F,GAAahJ,EACrB,IAAK2F,KAAKnF,aACN,OAAO,EAEX,MAAM6D,EAAasB,KAAKtF,SAAS0E,cAAc1B,GACzCiB,EAAkBqB,KAAKT,cAC7B,GAAIZ,IAAoBF,EAAYC,EAAYC,GAC5C,OAAO,EAEX,MAAMtB,EAAY2C,KAAK1C,eACvB,IAAKD,EAAUlC,OACX,OAAO,EAEX,MAAMwC,EAAQN,EAAUoF,QAAQ/E,GAChC,OAAI2F,EACO1F,IAAUN,EAAUlC,OAAS,EAE7BwC,GAAS,CAExB,CACA,WAAA4B,GACI,OAAOS,KAAKG,MAAMa,WAAWsC,cAAc1H,QAC/C,CACA,OAAA2H,GACI,OAAOvD,KAAKG,MAAMa,WAAWsC,cAAc9H,IAC/C,CACA,WAAA8C,GACI,OAAO0B,KAAKG,MAAMa,WAAWsC,cAAcvI,QAC/C,CACA,YAAAuC,GACI,OAAO0C,KAAKG,MAAMa,WAAWsC,cAAcjG,SAC/C,CACA,aAAAY,GACI,OAAO+B,KAAKG,MAAMa,WAAWsC,cAAc1F,UAC/C,CACA,OAAAR,GACI,OAAO4C,KAAKG,MAAMa,WAAWsC,cAAclG,OAC/C,CACA,cAAAtB,GACI,OAAOoH,QAAQlD,KAAKG,MAAMa,WAAWsC,cAAcxH,eACvD,CACA,sBAAA0H,GACI,OAAOxD,KAAKG,MAAMa,WAAW8B,WAAWW,mBAC5C,CACA,4BAAAC,GACI,OAAO1D,KAAKG,MAAMa,WAAW8B,WAAWa,yBAC5C,CACA,eAAAC,GACI,OAAO5D,KAAKG,MAAMa,WAAW8B,WAAWjJ,YAC5C,CACA,qBAAAU,GACI,OFjHG,SAA+B6H,GACtC,MAAM,aAAEvI,EAAa,oBAAE4J,EAAoB,0BAAEE,GAA+BvB,EAC5E,OAAKvI,GAAiB4J,GAAwBE,EAGvCtC,GA5BgBE,EA4BWoC,EA3B3B,CACHnC,GAFgBF,EA4BAzH,GA1BX2H,EAAID,EAAEC,EACXC,EAAGH,EAAEG,EAAIF,EAAEE,IAyB+CgC,GAFnD,KA1BJ,IAAanC,EAAGC,CA6B3B,CE2GehH,CAAsByF,KAAKG,MAAMa,WAAW8B,WACvD,CACA,8BAAAe,GACI,OFzGG,SAAwCzB,GAC/C,MAAM,aAAEvI,EAAa,oBAAE4J,GAAyBrB,EAChD,OAAKvI,GAAiB4J,EAGfpC,EAASxH,EAAc4J,GAFnB,IAGf,CEmGeI,CAA+B7D,KAAKG,MAAMa,WAAW8B,WAChE,CACA,WAAAlC,CAAYT,EAAOzF,GACfsF,KAAKG,MAAQA,EACbH,KAAKtF,SAAWA,CACpB,E,cCpJG,MAAMoJ,EAAa,sBACbC,EAAa,sBACbC,EAAgB,yBAChBC,EAAgB,yBCQtB,SAASC,EAAanK,EAAMoK,GAC3BA,GAAcvF,MAAMC,QAAQ9E,GAC5BA,EAAKe,SAASiE,GAAImF,EAAanF,GAAG,MAItC,OAA0B,iBAAThF,GAAqC,iBAATA,EAAmBoK,EAAa,8DAAgE,yCACjJ,CClBO,IAAIC,GACX,SAAUA,GACNA,EAAoB,OAAI,SACxBA,EAAoB,OAAI,QAC3B,CAHD,CAGGA,IAAgBA,EAAc,CAAC,ICJlC,IAAIC,EAAe,ECiBnB,SAASC,EAAuBC,GAC5B,OAAOA,EAAU,IACb,IAAK,IACD,OAAOH,EAAYI,OACvB,IAAK,IACD,OAAOJ,EAAYK,OACvB,QACI,MAAM,IAAInJ,MAAM,4BAA4BiJ,KAExD,CACA,SAASG,EAAiBC,EAAKC,GAC3B,MAAMC,EAAUF,EAAIE,UACpB,IAAIC,GAAS,EACb,EAAG,CACC,MAAM,KAAEC,EAAO7I,OAAQ,CAAEA,IAAc2I,EAAQG,OAC/C,GAAI9I,IAAU0I,EACV,OAAO,EAEXE,IAAWC,CACf,QAASD,GACT,OAAO,CACX,CACO,MAAMG,EACT,SAAAC,CAAUnL,EAAM4C,GACZuH,EAAanK,GHxCd,SAAgC4C,IACnC,OAAoC,mBAAnBA,EAAOqG,QAAwB,uCAChD,OAAsC,mBAArBrG,EAAOlB,UAA0B,yCAClD,OAAoC,mBAAnBkB,EAAO4B,QAAwB,qCACpD,CGqCQ4G,CAAuBxI,GACvB,MAAM5B,EAAWiF,KAAKoF,WAAWhB,EAAYI,OAAQzK,EAAM4C,GAE3D,OADAqD,KAAKG,MAAMvF,SJxCZ,SAAmBG,GACtB,MAAO,CACHhB,KAAM+J,EACN9J,QAAS,CACLe,YAGZ,CIiC4BmK,CAAUnK,IACvBA,CACX,CACA,SAAAsK,CAAUtL,EAAM0C,GACZyH,EAAanK,GAAM,GH1CpB,SAAgC0C,IACnC,OAAoC,mBAAnBA,EAAOwG,QAAwB,uCAChD,OAAkC,mBAAjBxG,EAAOiD,MAAsB,qCAC9C,OAAiC,mBAAhBjD,EAAOqB,KAAqB,uCACjD,CGuCQwH,CAAuB7I,GACvB,MAAMiB,EAAWsC,KAAKoF,WAAWhB,EAAYK,OAAQ1K,EAAM0C,GAE3D,OADAuD,KAAKG,MAAMvF,SJvCZ,SAAmB8C,GACtB,MAAO,CACH3D,KAAMgK,EACN/J,QAAS,CACL0D,YAGZ,CIgC4B2H,CAAU3H,IACvBA,CACX,CACA,eAAA6H,CAAgBC,GACZ,OAAOd,EAAiB1E,KAAKyF,YAAaD,IAAYd,EAAiB1E,KAAK0F,YAAaF,EAC7F,CACA,SAAAxK,CAAUD,EAAU4K,GAAgB,GAIhC,OAHA,OAAU3F,KAAK4F,WAAW7K,GAAW,+BACpB4K,GAAiB5K,IAAaiF,KAAK6F,eAC1B7F,KAAK8F,aAAe9F,KAAKyF,YAAYM,IAAIhL,EAEvE,CACA,SAAA8C,CAAUH,GAEN,OADA,OAAUsC,KAAKgG,WAAWtI,GAAW,+BAC9BsC,KAAK0F,YAAYK,IAAIrI,EAChC,CACA,aAAA7B,CAAcd,GAEV,OADA,OAAUiF,KAAK4F,WAAW7K,GAAW,+BAC9BiF,KAAKiG,MAAMF,IAAIhL,EAC1B,CACA,aAAAqE,CAAc1B,GAEV,OADA,OAAUsC,KAAKgG,WAAWtI,GAAW,+BAC9BsC,KAAKiG,MAAMF,IAAIrI,EAC1B,CACA,UAAAkI,CAAWrB,GAEP,OADaD,EAAuBC,KACpBH,EAAYI,MAChC,CACA,UAAAwB,CAAWzB,GAEP,OADaD,EAAuBC,KACpBH,EAAYK,MAChC,CACA,YAAAyB,CAAanL,IACT,OAAUiF,KAAKhF,UAAUD,GAAW,gCACpCiF,KAAKG,MAAMvF,SJjEZ,SAAsBG,GACzB,MAAO,CACHhB,KAAMiK,EACNhK,QAAS,CACLe,YAGZ,CI0D4BmL,CAAanL,KACjC,SAAK,KACDiF,KAAKyF,YAAYU,OAAOpL,GACxBiF,KAAKiG,MAAME,OAAOpL,EAAS,GAEnC,CACA,YAAAqL,CAAa1I,IACT,OAAUsC,KAAKnC,UAAUH,GAAW,gCACpCsC,KAAKG,MAAMvF,SJjEZ,SAAsB8C,GACzB,MAAO,CACH3D,KAAMkK,EACNjK,QAAS,CACL0D,YAGZ,CI0D4B0I,CAAa1I,IACjCsC,KAAK0F,YAAYS,OAAOzI,GACxBsC,KAAKiG,MAAME,OAAOzI,EACtB,CACA,SAAA/B,CAAUZ,GACN,MAAM4B,EAASqD,KAAKhF,UAAUD,IAC9B,OAAU4B,EAAQ,gCAClBqD,KAAK6F,eAAiB9K,EACtBiF,KAAK8F,aAAenJ,CACxB,CACA,WAAA6B,IACI,OAAUwB,KAAK8F,aAAc,oCAC7B9F,KAAK6F,eAAiB,KACtB7F,KAAK8F,aAAe,IACxB,CACA,UAAAV,CAAWiB,EAAMtM,EAAMyL,GACnB,MAAMc,EAvGd,SAA0BD,GACtB,MAAMC,GDLCjC,KCKsBkC,WAC7B,OAAOF,GACH,KAAKjC,EAAYI,OACb,MAAO,IAAI8B,IACf,KAAKlC,EAAYK,OACb,MAAO,IAAI6B,IACf,QACI,MAAM,IAAIhL,MAAM,yBAAyB+K,KAErD,CA6FmBG,CAAiBH,GAO5B,OANArG,KAAKiG,MAAMQ,IAAIH,EAAIvM,GACfsM,IAASjC,EAAYI,OACrBxE,KAAKyF,YAAYgB,IAAIH,EAAId,GAClBa,IAASjC,EAAYK,QAC5BzE,KAAK0F,YAAYe,IAAIH,EAAId,GAEtBc,CACX,CACA,WAAA1F,CAAYT,GACRH,KAAKiG,MAAQ,IAAIS,IACjB1G,KAAKyF,YAAc,IAAIiB,IACvB1G,KAAK0F,YAAc,IAAIgB,IACvB1G,KAAK6F,eAAiB,KACtB7F,KAAK8F,aAAe,KACpB9F,KAAKG,MAAQA,CACjB,EC7HG,MAAMwG,EAAiB,CAACrF,EAAGC,IAAID,IAAMC,ECKrC,SAAShB,EAChBqG,EAASlF,EAAMvD,GACX,OAAOA,EAAOpE,MACV,KAAKN,EACD,MACJ,KAAKqK,EACL,KAAKC,EACL,KAAKE,EACL,KAAKD,EACD,OAAOtC,EAKX,QACI,OAAOC,EAEf,MAAM,UAAEtE,EAAW,GAAG,cAAEwJ,EAAe,IAAQ1I,EAAOnE,QAChD8M,EpBSC,SAAaC,EAAQvE,GAC5B,MAAMmC,EAAM,IAAI+B,IACVM,EAAcxL,IAChBmJ,EAAI8B,IAAIjL,EAAMmJ,EAAIsC,IAAIzL,GAAQmJ,EAAIoB,IAAIvK,GAAQ,EAAI,EAAE,EAExDuL,EAAOjM,QAAQkM,GACfxE,EAAO1H,QAAQkM,GACf,MAAMF,EAAS,GAMf,OALAnC,EAAI7J,SAAQ,CAACoM,EAAOjL,KACF,IAAViL,GACAJ,EAAOK,KAAKlL,EAChB,IAEG6K,CACX,CoBvBmBM,CAAI/J,EAAWwJ,GAE9B,KADkBC,EAAO3L,OAAS,IDL3B,SAAwBmG,EAAGC,EAAG8F,EAAUV,GAC/C,GAAIrF,EAAEnG,SAAWoG,EAAEpG,OACf,OAAO,EAEX,IAAI,IAAID,EAAI,EAAGA,EAAIoG,EAAEnG,SAAUD,EAC3B,IAAKmM,EAAQ/F,EAAEpG,GAAIqG,EAAErG,IACjB,OAAO,EAGf,OAAO,CACX,CCL4CoM,CAAejK,EAAWwJ,GAE9D,OAAOnF,EAIX,MAAM6F,EAAwBV,EAAcA,EAAc1L,OAAS,GAC7DqM,EAAoBnK,EAAUA,EAAUlC,OAAS,GASvD,OARIoM,IAA0BC,IACtBD,GACAT,EAAOK,KAAKI,GAEZC,GACAV,EAAOK,KAAKK,IAGbV,CACX,CCzCA,SAAS,EAAgB9K,EAAKC,EAAKC,GAW/B,OAVID,KAAOD,EACPG,OAAOC,eAAeJ,EAAKC,EAAK,CAC5BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdP,EAAIC,GAAOC,EAERF,CACX,CAkBA,MAAMyL,EAAe,CACjB9D,0BAA2B,KAC3BF,oBAAqB,KACrB5J,aAAc,MAEX,SAAS,EAAOuI,EAAQqF,EAActJ,GACzC,MAAM,QAAEnE,GAAamE,EACrB,OAAOA,EAAOpE,MACV,KAAKT,EACL,KAAKC,EACD,MAAO,CACHoK,0BAA2B3J,EAAQF,mBACnC2J,oBAAqBzJ,EAAQH,aAC7BA,aAAcG,EAAQH,cAE9B,KAAKJ,EACD,OFxCuBiO,EEwCJtF,EAAMvI,aFxCO8N,EEwCO3N,EAAQH,cFvClD6N,IAAYC,GAELD,GAAYC,GAGbD,EAAQlG,IAAMmG,EAAQnG,GAAKkG,EAAQjG,IAAMkG,EAAQlG,EEmCzCW,EAlCvB,SAAuB3F,GACnB,IAAI,IAAIvB,EAAI,EAAGA,EAAIwB,UAAUvB,OAAQD,IAAI,CACrC,IAAIyB,EAAyB,MAAhBD,UAAUxB,GAAawB,UAAUxB,GAAK,CAAC,EAChD0B,EAAUT,OAAOU,KAAKF,GACkB,mBAAjCR,OAAOW,wBACdF,EAAUA,EAAQG,OAAOZ,OAAOW,sBAAsBH,GAAQK,QAAO,SAASC,GAC1E,OAAOd,OAAOe,yBAAyBP,EAAQM,GAAKZ,UACxD,MAEJO,EAAQ9B,SAAQ,SAASmB,GACrB,EAAgBQ,EAAQR,EAAKU,EAAOV,GACxC,GACJ,CACA,OAAOQ,CACX,CAsBmB,CAAc,CAAC,EAAG2F,EAAO,CAC5BvI,aAAcG,EAAQH,eAE9B,KAAKF,EACL,KAAKD,EACD,OAAO+N,EACX,QACI,OAAOrF,EFlDR,IAAwBsF,EAASC,CEoD5C,CC1DA,SAAS,EAAgB3L,EAAKC,EAAKC,GAW/B,OAVID,KAAOD,EACPG,OAAOC,eAAeJ,EAAKC,EAAK,CAC5BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdP,EAAIC,GAAOC,EAERF,CACX,CACA,SAAS,EAAcS,GACnB,IAAI,IAAIvB,EAAI,EAAGA,EAAIwB,UAAUvB,OAAQD,IAAI,CACrC,IAAIyB,EAAyB,MAAhBD,UAAUxB,GAAawB,UAAUxB,GAAK,CAAC,EAChD0B,EAAUT,OAAOU,KAAKF,GACkB,mBAAjCR,OAAOW,wBACdF,EAAUA,EAAQG,OAAOZ,OAAOW,sBAAsBH,GAAQK,QAAO,SAASC,GAC1E,OAAOd,OAAOe,yBAAyBP,EAAQM,GAAKZ,UACxD,MAEJO,EAAQ9B,SAAQ,SAASmB,GACrB,EAAgBQ,EAAQR,EAAKU,EAAOV,GACxC,GACJ,CACA,OAAOQ,CACX,CAIA,MAAM,EAAe,CACjBb,SAAU,KACVJ,KAAM,KACNT,SAAU,KACVsC,UAAW,GACXO,WAAY,KACZR,SAAS,EACTtB,eAAgB,MAEb,SAAS,EAAOsG,EAAQ,EAAcjE,GACzC,MAAM,QAAEnE,GAAamE,EACrB,OAAOA,EAAOpE,MACV,KAAKR,EACD,OAAO,EAAc,CAAC,EAAG6I,EAAO,CAC5BxG,SAAU5B,EAAQ4B,SAClBJ,KAAMxB,EAAQwB,KACdT,SAAUf,EAAQe,SAClBe,eAAgB9B,EAAQ8B,eACxB8B,WAAY,KACZR,SAAS,IAEjB,KAAK5D,EACD,OAAO,EAAc,CAAC,EAAG4I,EAAO,CAC5BtG,gBAAgB,IAExB,KAAKrC,EACD,OAAO,EAAc,CAAC,EAAG2I,EAAO,CAC5B/E,UAAWrD,EAAQqD,YAE3B,KAAK4G,EACD,OAAmD,IAA/C7B,EAAM/E,UAAUoF,QAAQzI,EAAQ0D,UACzB0E,EAEJ,EAAc,CAAC,EAAGA,EAAO,CAC5B/E,WtBrDYuK,EsBqDOxF,EAAM/E,UtBrDN7B,EsBqDiBxB,EAAQ0D,StBpDjDkK,EAAM5K,QAAQ9B,GAAIA,IAAMM,OsBsD3B,KAAK9B,EACD,OAAO,EAAc,CAAC,EAAG0I,EAAO,CAC5BxE,WAAY5D,EAAQ4D,WACpBR,SAAS,EACTC,UAAW,KAEnB,KAAK1D,EACD,OAAO,EAAc,CAAC,EAAGyI,EAAO,CAC5BxG,SAAU,KACVJ,KAAM,KACNT,SAAU,KACV6C,WAAY,KACZR,SAAS,EACTtB,eAAgB,KAChBuB,UAAW,KAEnB,QACI,OAAO+E,EtBxER,IAAiBwF,EAAOpM,CsB0EnC,CCrFO,SAAS,EAAO4G,EAAQ,EAAGjE,GAC9B,OAAOA,EAAOpE,MACV,KAAK+J,EACL,KAAKC,EACD,OAAO3B,EAAQ,EACnB,KAAK4B,EACL,KAAKC,EACD,OAAO7B,EAAQ,EACnB,QACI,OAAOA,EAEnB,CCZO,SAAS,EAAOA,EAAQ,GAC3B,OAAOA,EAAQ,CACnB,CCFA,SAAS,EAAgBpG,EAAKC,EAAKC,GAW/B,OAVID,KAAOD,EACPG,OAAOC,eAAeJ,EAAKC,EAAK,CAC5BC,MAAOA,EACPG,YAAY,EACZC,cAAc,EACdC,UAAU,IAGdP,EAAIC,GAAOC,EAERF,CACX,CACA,SAAS,EAAcS,GACnB,IAAI,IAAIvB,EAAI,EAAGA,EAAIwB,UAAUvB,OAAQD,IAAI,CACrC,IAAIyB,EAAyB,MAAhBD,UAAUxB,GAAawB,UAAUxB,GAAK,CAAC,EAChD0B,EAAUT,OAAOU,KAAKF,GACkB,mBAAjCR,OAAOW,wBACdF,EAAUA,EAAQG,OAAOZ,OAAOW,sBAAsBH,GAAQK,QAAO,SAASC,GAC1E,OAAOd,OAAOe,yBAAyBP,EAAQM,GAAKZ,UACxD,MAEJO,EAAQ9B,SAAQ,SAASmB,GACrB,EAAgBQ,EAAQR,EAAKU,EAAOV,GACxC,GACJ,CACA,OAAOQ,CACX,CAOO,SAAS,EAAO2F,EAAQ,CAAC,EAAGjE,GAC/B,MAAO,CACHwE,gBAAiB,EAAgBP,EAAMO,gBAAiB,CACpD5I,KAAMoE,EAAOpE,KACbC,QAAS,EAAc,CAAC,EAAGmE,EAAOnE,QAAS,CACvC6M,ezBjCQ7K,EyBiCWoG,EzBjCAyF,EyBiCkC,GAA3B,0BzBhC1BC,MAAM,KAAKvH,QAAO,CAACe,EAAGyG,IAAIzG,GAAKA,EAAEyG,GAAKzG,EAAEyG,GAAKF,GAAgB,MACvE7L,QyBkCE8G,WAAY,EAAWV,EAAMU,WAAY3E,GACzC8C,SAAU,EAASmB,EAAMnB,SAAU9C,GACnCmF,cAAe,EAAclB,EAAMkB,cAAenF,GAClDgE,QAAS,EAAQC,EAAMD,UzBvCpB,IAAanG,EAAW6L,CyByCnC,CC1CO,SAASG,EAAsBC,EAAgBC,OAAgBnK,EAAWoK,EAAiB,CAAC,EAAGC,GAAY,GAC9G,MAAMjI,EAOV,SAA2BiI,GAGvB,MAAMC,EAAkC,oBAAXC,QAA0BA,OAAOC,6BAC9D,OAAO,QAAY,EAAQH,GAAaC,GAAiBA,EAAc,CACnEG,KAAM,WACNC,WAAY,aAEpB,CAfkBC,CAAkBN,GAC1B5N,EAAU,IAAIsH,EAAoB3B,EAAO,IAAI8E,EAAoB9E,IACjEhG,EAAU,IAAI0F,EAAoBM,EAAO3F,GACzCuF,EAAUkI,EAAe9N,EAAS+N,EAAeC,GAEvD,OADAhO,EAAQ2F,eAAeC,GAChB5F,CACX,C","sources":["webpack://ai-tab-manager/./node_modules/dnd-core/dist/utils/js_utils.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/types.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/drop.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/endDrag.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/utils/matchesType.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/hover.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/classes/DragDropManagerImpl.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/dragDrop/index.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/utils/coords.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/utils/dirtiness.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/actions/registry.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/contracts.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/interfaces.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/utils/getNextUniqueId.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/utils/equality.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/reducers/dragOffset.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/reducers/dragOperation.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/reducers/refCount.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/reducers/stateId.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/reducers/index.js","webpack://ai-tab-manager/./node_modules/dnd-core/dist/createDragDropManager.js"],"sourcesContent":["// cheap lodash replacements\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */ export function get(obj, path, defaultValue) {\n    return path.split('.').reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null\n    , obj);\n}\n/**\n * drop-in replacement for _.without\n */ export function without(items, item) {\n    return items.filter((i)=>i !== item\n    );\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ export function isString(input) {\n    return typeof input === 'string';\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ export function isObject(input) {\n    return typeof input === 'object';\n}\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */ export function xor(itemsA, itemsB) {\n    const map = new Map();\n    const insertItem = (item)=>{\n        map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n    };\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    map.forEach((count, key)=>{\n        if (count === 1) {\n            result.push(key);\n        }\n    });\n    return result;\n}\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */ export function intersection(itemsA, itemsB) {\n    return itemsA.filter((t)=>itemsB.indexOf(t) > -1\n    );\n}\n\n//# sourceMappingURL=js_utils.js.map","export const INIT_COORDS = 'dnd-core/INIT_COORDS';\nexport const BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nexport const PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nexport const HOVER = 'dnd-core/HOVER';\nexport const DROP = 'dnd-core/DROP';\nexport const END_DRAG = 'dnd-core/END_DRAG';\n\n//# sourceMappingURL=types.js.map","import { INIT_COORDS } from '../types.js';\nexport function setClientOffset(clientOffset, sourceClientOffset) {\n    return {\n        type: INIT_COORDS,\n        payload: {\n            sourceClientOffset: sourceClientOffset || null,\n            clientOffset: clientOffset || null\n        }\n    };\n}\n\n//# sourceMappingURL=setClientOffset.js.map","import { invariant } from '@react-dnd/invariant';\nimport { isObject } from '../../utils/js_utils.js';\nimport { setClientOffset } from './local/setClientOffset.js';\nimport { BEGIN_DRAG, INIT_COORDS } from './types.js';\nconst ResetCoordinatesAction = {\n    type: INIT_COORDS,\n    payload: {\n        clientOffset: null,\n        sourceClientOffset: null\n    }\n};\nexport function createBeginDrag(manager) {\n    return function beginDrag(sourceIds = [], options = {\n        publishSource: true\n    }) {\n        const { publishSource =true , clientOffset , getSourceClientOffset ,  } = options;\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        // Initialize the coordinates using the client offset\n        manager.dispatch(setClientOffset(clientOffset));\n        verifyInvariants(sourceIds, monitor, registry);\n        // Get the draggable source\n        const sourceId = getDraggableSource(sourceIds, monitor);\n        if (sourceId == null) {\n            manager.dispatch(ResetCoordinatesAction);\n            return;\n        }\n        // Get the source client offset\n        let sourceClientOffset = null;\n        if (clientOffset) {\n            if (!getSourceClientOffset) {\n                throw new Error('getSourceClientOffset must be defined');\n            }\n            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);\n            sourceClientOffset = getSourceClientOffset(sourceId);\n        }\n        // Initialize the full coordinates\n        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));\n        const source = registry.getSource(sourceId);\n        const item = source.beginDrag(monitor, sourceId);\n        // If source.beginDrag returns null, this is an indicator to cancel the drag\n        if (item == null) {\n            return undefined;\n        }\n        verifyItemIsObject(item);\n        registry.pinSource(sourceId);\n        const itemType = registry.getSourceType(sourceId);\n        return {\n            type: BEGIN_DRAG,\n            payload: {\n                itemType,\n                item,\n                sourceId,\n                clientOffset: clientOffset || null,\n                sourceClientOffset: sourceClientOffset || null,\n                isSourcePublic: !!publishSource\n            }\n        };\n    };\n}\nfunction verifyInvariants(sourceIds, monitor, registry) {\n    invariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n    sourceIds.forEach(function(sourceId) {\n        invariant(registry.getSource(sourceId), 'Expected sourceIds to be registered.');\n    });\n}\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {\n    invariant(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n}\nfunction verifyItemIsObject(item) {\n    invariant(isObject(item), 'Item must be an object.');\n}\nfunction getDraggableSource(sourceIds, monitor) {\n    let sourceId = null;\n    for(let i = sourceIds.length - 1; i >= 0; i--){\n        if (monitor.canDragSource(sourceIds[i])) {\n            sourceId = sourceIds[i];\n            break;\n        }\n    }\n    return sourceId;\n}\n\n//# sourceMappingURL=beginDrag.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { invariant } from '@react-dnd/invariant';\nimport { isObject } from '../../utils/js_utils.js';\nimport { DROP } from './types.js';\nexport function createDrop(manager) {\n    return function drop(options = {}) {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyInvariants(monitor);\n        const targetIds = getDroppableTargets(monitor);\n        // Multiple actions are dispatched here, which is why this doesn't return an action\n        targetIds.forEach((targetId, index)=>{\n            const dropResult = determineDropResult(targetId, index, registry, monitor);\n            const action = {\n                type: DROP,\n                payload: {\n                    dropResult: _objectSpread({}, options, dropResult)\n                }\n            };\n            manager.dispatch(action);\n        });\n    };\n}\nfunction verifyInvariants(monitor) {\n    invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n}\nfunction determineDropResult(targetId, index, registry, monitor) {\n    const target = registry.getTarget(targetId);\n    let dropResult = target ? target.drop(monitor, targetId) : undefined;\n    verifyDropResultType(dropResult);\n    if (typeof dropResult === 'undefined') {\n        dropResult = index === 0 ? {} : monitor.getDropResult();\n    }\n    return dropResult;\n}\nfunction verifyDropResultType(dropResult) {\n    invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');\n}\nfunction getDroppableTargets(monitor) {\n    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n    targetIds.reverse();\n    return targetIds;\n}\n\n//# sourceMappingURL=drop.js.map","import { invariant } from '@react-dnd/invariant';\nimport { END_DRAG } from './types.js';\nexport function createEndDrag(manager) {\n    return function endDrag() {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyIsDragging(monitor);\n        const sourceId = monitor.getSourceId();\n        if (sourceId != null) {\n            const source = registry.getSource(sourceId, true);\n            source.endDrag(monitor, sourceId);\n            registry.unpinSource();\n        }\n        return {\n            type: END_DRAG\n        };\n    };\n}\nfunction verifyIsDragging(monitor) {\n    invariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n}\n\n//# sourceMappingURL=endDrag.js.map","export function matchesType(targetType, draggedItemType) {\n    if (draggedItemType === null) {\n        return targetType === null;\n    }\n    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType\n    ) : targetType === draggedItemType;\n}\n\n//# sourceMappingURL=matchesType.js.map","import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from '../../utils/matchesType.js';\nimport { HOVER } from './types.js';\nexport function createHover(manager) {\n    return function hover(targetIdsArg, { clientOffset  } = {}) {\n        verifyTargetIdsIsArray(targetIdsArg);\n        const targetIds = targetIdsArg.slice(0);\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        const draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        checkInvariants(targetIds, monitor, registry);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: HOVER,\n            payload: {\n                targetIds,\n                clientOffset: clientOffset || null\n            }\n        };\n    };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n    for(let i = 0; i < targetIds.length; i++){\n        const targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n        const target = registry.getTarget(targetId);\n        invariant(target, 'Expected targetIds to be registered.');\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for(let i = targetIds.length - 1; i >= 0; i--){\n        const targetId = targetIds[i];\n        const targetType = registry.getTargetType(targetId);\n        if (!matchesType(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function(targetId) {\n        const target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\n\n//# sourceMappingURL=hover.js.map","import { PUBLISH_DRAG_SOURCE } from './types.js';\nexport function createPublishDragSource(manager) {\n    return function publishDragSource() {\n        const monitor = manager.getMonitor();\n        if (monitor.isDragging()) {\n            return {\n                type: PUBLISH_DRAG_SOURCE\n            };\n        }\n        return;\n    };\n}\n\n//# sourceMappingURL=publishDragSource.js.map","import { createDragDropActions } from '../actions/dragDrop/index.js';\nexport class DragDropManagerImpl {\n    receiveBackend(backend) {\n        this.backend = backend;\n    }\n    getMonitor() {\n        return this.monitor;\n    }\n    getBackend() {\n        return this.backend;\n    }\n    getRegistry() {\n        return this.monitor.registry;\n    }\n    getActions() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;\n        const { dispatch  } = this.store;\n        function bindActionCreator(actionCreator) {\n            return (...args)=>{\n                const action = actionCreator.apply(manager, args);\n                if (typeof action !== 'undefined') {\n                    dispatch(action);\n                }\n            };\n        }\n        const actions = createDragDropActions(this);\n        return Object.keys(actions).reduce((boundActions, key)=>{\n            const action = actions[key];\n            boundActions[key] = bindActionCreator(action);\n            return boundActions;\n        }, {});\n    }\n    dispatch(action) {\n        this.store.dispatch(action);\n    }\n    constructor(store, monitor){\n        this.isSetUp = false;\n        this.handleRefCountChange = ()=>{\n            const shouldSetUp = this.store.getState().refCount > 0;\n            if (this.backend) {\n                if (shouldSetUp && !this.isSetUp) {\n                    this.backend.setup();\n                    this.isSetUp = true;\n                } else if (!shouldSetUp && this.isSetUp) {\n                    this.backend.teardown();\n                    this.isSetUp = false;\n                }\n            }\n        };\n        this.store = store;\n        this.monitor = monitor;\n        store.subscribe(this.handleRefCountChange);\n    }\n}\n\n//# sourceMappingURL=DragDropManagerImpl.js.map","import { createBeginDrag } from './beginDrag.js';\nimport { createDrop } from './drop.js';\nimport { createEndDrag } from './endDrag.js';\nimport { createHover } from './hover.js';\nimport { createPublishDragSource } from './publishDragSource.js';\nexport * from './types.js';\nexport function createDragDropActions(manager) {\n    return {\n        beginDrag: createBeginDrag(manager),\n        publishDragSource: createPublishDragSource(manager),\n        hover: createHover(manager),\n        drop: createDrop(manager),\n        endDrag: createEndDrag(manager)\n    };\n}\n\n//# sourceMappingURL=index.js.map","/**\n * Coordinate addition\n * @param a The first coordinate\n * @param b The second coordinate\n */ export function add(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y\n    };\n}\n/**\n * Coordinate subtraction\n * @param a The first coordinate\n * @param b The second coordinate\n */ export function subtract(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\n/**\n * Returns the cartesian distance of the drag source component's position, based on its position\n * at the time when the current drag operation has started, and the movement difference.\n *\n * Returns null if no item is being dragged.\n *\n * @param state The offset state to compute from\n */ export function getSourceClientOffset(state) {\n    const { clientOffset , initialClientOffset , initialSourceClientOffset  } = state;\n    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n        return null;\n    }\n    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);\n}\n/**\n * Determines the x,y offset between the client offset and the initial client offset\n *\n * @param state The offset state to compute from\n */ export function getDifferenceFromInitialOffset(state) {\n    const { clientOffset , initialClientOffset  } = state;\n    if (!clientOffset || !initialClientOffset) {\n        return null;\n    }\n    return subtract(clientOffset, initialClientOffset);\n}\n\n//# sourceMappingURL=coords.js.map","import { intersection } from './js_utils.js';\nexport const NONE = [];\nexport const ALL = [];\nNONE.__IS_NONE__ = true;\nALL.__IS_ALL__ = true;\n/**\n * Determines if the given handler IDs are dirty or not.\n *\n * @param dirtyIds The set of dirty handler ids\n * @param handlerIds The set of handler ids to check\n */ export function areDirty(dirtyIds, handlerIds) {\n    if (dirtyIds === NONE) {\n        return false;\n    }\n    if (dirtyIds === ALL || typeof handlerIds === 'undefined') {\n        return true;\n    }\n    const commonIds = intersection(handlerIds, dirtyIds);\n    return commonIds.length > 0;\n}\n\n//# sourceMappingURL=dirtiness.js.map","import { invariant } from '@react-dnd/invariant';\nimport { getDifferenceFromInitialOffset, getSourceClientOffset } from '../utils/coords.js';\nimport { areDirty } from '../utils/dirtiness.js';\nimport { matchesType } from '../utils/matchesType.js';\nexport class DragDropMonitorImpl {\n    subscribeToStateChange(listener, options = {}) {\n        const { handlerIds  } = options;\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n        let prevStateId = this.store.getState().stateId;\n        const handleChange = ()=>{\n            const state = this.store.getState();\n            const currentStateId = state.stateId;\n            try {\n                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n                if (!canSkipListener) {\n                    listener();\n                }\n            } finally{\n                prevStateId = currentStateId;\n            }\n        };\n        return this.store.subscribe(handleChange);\n    }\n    subscribeToOffsetChange(listener) {\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        let previousState = this.store.getState().dragOffset;\n        const handleChange = ()=>{\n            const nextState = this.store.getState().dragOffset;\n            if (nextState === previousState) {\n                return;\n            }\n            previousState = nextState;\n            listener();\n        };\n        return this.store.subscribe(handleChange);\n    }\n    canDragSource(sourceId) {\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (this.isDragging()) {\n            return false;\n        }\n        return source.canDrag(this, sourceId);\n    }\n    canDropOnTarget(targetId) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const target = this.registry.getTarget(targetId);\n        invariant(target, `Expected to find a valid target. targetId=${targetId}`);\n        if (!this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n    isDragging() {\n        return Boolean(this.getItemType());\n    }\n    isDraggingSource(sourceId) {\n        // undefined on initial render\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId, true);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (!this.isDragging() || !this.isSourcePublic()) {\n            return false;\n        }\n        const sourceType = this.registry.getSourceType(sourceId);\n        const draggedItemType = this.getItemType();\n        if (sourceType !== draggedItemType) {\n            return false;\n        }\n        return source.isDragging(this, sourceId);\n    }\n    isOverTarget(targetId, options = {\n        shallow: false\n    }) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const { shallow  } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        } else {\n            return index > -1;\n        }\n    }\n    getItemType() {\n        return this.store.getState().dragOperation.itemType;\n    }\n    getItem() {\n        return this.store.getState().dragOperation.item;\n    }\n    getSourceId() {\n        return this.store.getState().dragOperation.sourceId;\n    }\n    getTargetIds() {\n        return this.store.getState().dragOperation.targetIds;\n    }\n    getDropResult() {\n        return this.store.getState().dragOperation.dropResult;\n    }\n    didDrop() {\n        return this.store.getState().dragOperation.didDrop;\n    }\n    isSourcePublic() {\n        return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n    getInitialClientOffset() {\n        return this.store.getState().dragOffset.initialClientOffset;\n    }\n    getInitialSourceClientOffset() {\n        return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n    getClientOffset() {\n        return this.store.getState().dragOffset.clientOffset;\n    }\n    getSourceClientOffset() {\n        return getSourceClientOffset(this.store.getState().dragOffset);\n    }\n    getDifferenceFromInitialOffset() {\n        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n    constructor(store, registry){\n        this.store = store;\n        this.registry = registry;\n    }\n}\n\n//# sourceMappingURL=DragDropMonitorImpl.js.map","export const ADD_SOURCE = 'dnd-core/ADD_SOURCE';\nexport const ADD_TARGET = 'dnd-core/ADD_TARGET';\nexport const REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';\nexport const REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';\nexport function addSource(sourceId) {\n    return {\n        type: ADD_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nexport function addTarget(targetId) {\n    return {\n        type: ADD_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nexport function removeSource(sourceId) {\n    return {\n        type: REMOVE_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nexport function removeTarget(targetId) {\n    return {\n        type: REMOVE_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\n\n//# sourceMappingURL=registry.js.map","import { invariant } from '@react-dnd/invariant';\nexport function validateSourceContract(source) {\n    invariant(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');\n    invariant(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');\n    invariant(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');\n}\nexport function validateTargetContract(target) {\n    invariant(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');\n    invariant(typeof target.hover === 'function', 'Expected hover to be a function.');\n    invariant(typeof target.drop === 'function', 'Expected beginDrag to be a function.');\n}\nexport function validateType(type, allowArray) {\n    if (allowArray && Array.isArray(type)) {\n        type.forEach((t)=>validateType(t, false)\n        );\n        return;\n    }\n    invariant(typeof type === 'string' || typeof type === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');\n}\n\n//# sourceMappingURL=contracts.js.map","export var HandlerRole;\n(function(HandlerRole) {\n    HandlerRole[\"SOURCE\"] = \"SOURCE\";\n    HandlerRole[\"TARGET\"] = \"TARGET\";\n})(HandlerRole || (HandlerRole = {}));\n\n//# sourceMappingURL=interfaces.js.map","let nextUniqueId = 0;\nexport function getNextUniqueId() {\n    return nextUniqueId++;\n}\n\n//# sourceMappingURL=getNextUniqueId.js.map","import { asap } from '@react-dnd/asap';\nimport { invariant } from '@react-dnd/invariant';\nimport { addSource, addTarget, removeSource, removeTarget } from '../actions/registry.js';\nimport { validateSourceContract, validateTargetContract, validateType } from '../contracts.js';\nimport { HandlerRole } from '../interfaces.js';\nimport { getNextUniqueId } from '../utils/getNextUniqueId.js';\nfunction getNextHandlerId(role) {\n    const id = getNextUniqueId().toString();\n    switch(role){\n        case HandlerRole.SOURCE:\n            return `S${id}`;\n        case HandlerRole.TARGET:\n            return `T${id}`;\n        default:\n            throw new Error(`Unknown Handler Role: ${role}`);\n    }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n    switch(handlerId[0]){\n        case 'S':\n            return HandlerRole.SOURCE;\n        case 'T':\n            return HandlerRole.TARGET;\n        default:\n            throw new Error(`Cannot parse handler ID: ${handlerId}`);\n    }\n}\nfunction mapContainsValue(map, searchValue) {\n    const entries = map.entries();\n    let isDone = false;\n    do {\n        const { done , value: [, value] ,  } = entries.next();\n        if (value === searchValue) {\n            return true;\n        }\n        isDone = !!done;\n    }while (!isDone)\n    return false;\n}\nexport class HandlerRegistryImpl {\n    addSource(type, source) {\n        validateType(type);\n        validateSourceContract(source);\n        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n        this.store.dispatch(addSource(sourceId));\n        return sourceId;\n    }\n    addTarget(type, target) {\n        validateType(type, true);\n        validateTargetContract(target);\n        const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n        this.store.dispatch(addTarget(targetId));\n        return targetId;\n    }\n    containsHandler(handler) {\n        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n    }\n    getSource(sourceId, includePinned = false) {\n        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n        const isPinned = includePinned && sourceId === this.pinnedSourceId;\n        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n        return source;\n    }\n    getTarget(targetId) {\n        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n        return this.dropTargets.get(targetId);\n    }\n    getSourceType(sourceId) {\n        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n        return this.types.get(sourceId);\n    }\n    getTargetType(targetId) {\n        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n        return this.types.get(targetId);\n    }\n    isSourceId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.SOURCE;\n    }\n    isTargetId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.TARGET;\n    }\n    removeSource(sourceId) {\n        invariant(this.getSource(sourceId), 'Expected an existing source.');\n        this.store.dispatch(removeSource(sourceId));\n        asap(()=>{\n            this.dragSources.delete(sourceId);\n            this.types.delete(sourceId);\n        });\n    }\n    removeTarget(targetId) {\n        invariant(this.getTarget(targetId), 'Expected an existing target.');\n        this.store.dispatch(removeTarget(targetId));\n        this.dropTargets.delete(targetId);\n        this.types.delete(targetId);\n    }\n    pinSource(sourceId) {\n        const source = this.getSource(sourceId);\n        invariant(source, 'Expected an existing source.');\n        this.pinnedSourceId = sourceId;\n        this.pinnedSource = source;\n    }\n    unpinSource() {\n        invariant(this.pinnedSource, 'No source is pinned at the time.');\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n    }\n    addHandler(role, type, handler) {\n        const id = getNextHandlerId(role);\n        this.types.set(id, type);\n        if (role === HandlerRole.SOURCE) {\n            this.dragSources.set(id, handler);\n        } else if (role === HandlerRole.TARGET) {\n            this.dropTargets.set(id, handler);\n        }\n        return id;\n    }\n    constructor(store){\n        this.types = new Map();\n        this.dragSources = new Map();\n        this.dropTargets = new Map();\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n        this.store = store;\n    }\n}\n\n//# sourceMappingURL=HandlerRegistryImpl.js.map","export const strictEquality = (a, b)=>a === b\n;\n/**\n * Determine if two cartesian coordinate offsets are equal\n * @param offsetA\n * @param offsetB\n */ export function areCoordsEqual(offsetA, offsetB) {\n    if (!offsetA && !offsetB) {\n        return true;\n    } else if (!offsetA || !offsetB) {\n        return false;\n    } else {\n        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;\n    }\n}\n/**\n * Determines if two arrays of items are equal\n * @param a The first array of items\n * @param b The second array of items\n */ export function areArraysEqual(a, b, isEqual = strictEquality) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; ++i){\n        if (!isEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=equality.js.map","import { BEGIN_DRAG, DROP, END_DRAG, HOVER, PUBLISH_DRAG_SOURCE } from '../actions/dragDrop/index.js';\nimport { ADD_SOURCE, ADD_TARGET, REMOVE_SOURCE, REMOVE_TARGET } from '../actions/registry.js';\nimport { ALL, NONE } from '../utils/dirtiness.js';\nimport { areArraysEqual } from '../utils/equality.js';\nimport { xor } from '../utils/js_utils.js';\nexport function reduce(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_state = NONE, action) {\n    switch(action.type){\n        case HOVER:\n            break;\n        case ADD_SOURCE:\n        case ADD_TARGET:\n        case REMOVE_TARGET:\n        case REMOVE_SOURCE:\n            return NONE;\n        case BEGIN_DRAG:\n        case PUBLISH_DRAG_SOURCE:\n        case END_DRAG:\n        case DROP:\n        default:\n            return ALL;\n    }\n    const { targetIds =[] , prevTargetIds =[]  } = action.payload;\n    const result = xor(targetIds, prevTargetIds);\n    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);\n    if (!didChange) {\n        return NONE;\n    }\n    // Check the target ids at the innermost position. If they are valid, add them\n    // to the result\n    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];\n    const innermostTargetId = targetIds[targetIds.length - 1];\n    if (prevInnermostTargetId !== innermostTargetId) {\n        if (prevInnermostTargetId) {\n            result.push(prevInnermostTargetId);\n        }\n        if (innermostTargetId) {\n            result.push(innermostTargetId);\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=dirtyHandlerIds.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { BEGIN_DRAG, DROP, END_DRAG, HOVER, INIT_COORDS } from '../actions/dragDrop/index.js';\nimport { areCoordsEqual } from '../utils/equality.js';\nconst initialState = {\n    initialSourceClientOffset: null,\n    initialClientOffset: null,\n    clientOffset: null\n};\nexport function reduce(state = initialState, action) {\n    const { payload  } = action;\n    switch(action.type){\n        case INIT_COORDS:\n        case BEGIN_DRAG:\n            return {\n                initialSourceClientOffset: payload.sourceClientOffset,\n                initialClientOffset: payload.clientOffset,\n                clientOffset: payload.clientOffset\n            };\n        case HOVER:\n            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n                return state;\n            }\n            return _objectSpread({}, state, {\n                clientOffset: payload.clientOffset\n            });\n        case END_DRAG:\n        case DROP:\n            return initialState;\n        default:\n            return state;\n    }\n}\n\n//# sourceMappingURL=dragOffset.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { BEGIN_DRAG, DROP, END_DRAG, HOVER, PUBLISH_DRAG_SOURCE } from '../actions/dragDrop/index.js';\nimport { REMOVE_TARGET } from '../actions/registry.js';\nimport { without } from '../utils/js_utils.js';\nconst initialState = {\n    itemType: null,\n    item: null,\n    sourceId: null,\n    targetIds: [],\n    dropResult: null,\n    didDrop: false,\n    isSourcePublic: null\n};\nexport function reduce(state = initialState, action) {\n    const { payload  } = action;\n    switch(action.type){\n        case BEGIN_DRAG:\n            return _objectSpread({}, state, {\n                itemType: payload.itemType,\n                item: payload.item,\n                sourceId: payload.sourceId,\n                isSourcePublic: payload.isSourcePublic,\n                dropResult: null,\n                didDrop: false\n            });\n        case PUBLISH_DRAG_SOURCE:\n            return _objectSpread({}, state, {\n                isSourcePublic: true\n            });\n        case HOVER:\n            return _objectSpread({}, state, {\n                targetIds: payload.targetIds\n            });\n        case REMOVE_TARGET:\n            if (state.targetIds.indexOf(payload.targetId) === -1) {\n                return state;\n            }\n            return _objectSpread({}, state, {\n                targetIds: without(state.targetIds, payload.targetId)\n            });\n        case DROP:\n            return _objectSpread({}, state, {\n                dropResult: payload.dropResult,\n                didDrop: true,\n                targetIds: []\n            });\n        case END_DRAG:\n            return _objectSpread({}, state, {\n                itemType: null,\n                item: null,\n                sourceId: null,\n                dropResult: null,\n                didDrop: false,\n                isSourcePublic: null,\n                targetIds: []\n            });\n        default:\n            return state;\n    }\n}\n\n//# sourceMappingURL=dragOperation.js.map","import { ADD_SOURCE, ADD_TARGET, REMOVE_SOURCE, REMOVE_TARGET } from '../actions/registry.js';\nexport function reduce(state = 0, action) {\n    switch(action.type){\n        case ADD_SOURCE:\n        case ADD_TARGET:\n            return state + 1;\n        case REMOVE_SOURCE:\n        case REMOVE_TARGET:\n            return state - 1;\n        default:\n            return state;\n    }\n}\n\n//# sourceMappingURL=refCount.js.map","export function reduce(state = 0) {\n    return state + 1;\n}\n\n//# sourceMappingURL=stateId.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { get } from '../utils/js_utils.js';\nimport { reduce as dirtyHandlerIds } from './dirtyHandlerIds.js';\nimport { reduce as dragOffset } from './dragOffset.js';\nimport { reduce as dragOperation } from './dragOperation.js';\nimport { reduce as refCount } from './refCount.js';\nimport { reduce as stateId } from './stateId.js';\nexport function reduce(state = {}, action) {\n    return {\n        dirtyHandlerIds: dirtyHandlerIds(state.dirtyHandlerIds, {\n            type: action.type,\n            payload: _objectSpread({}, action.payload, {\n                prevTargetIds: get(state, 'dragOperation.targetIds', [])\n            })\n        }),\n        dragOffset: dragOffset(state.dragOffset, action),\n        refCount: refCount(state.refCount, action),\n        dragOperation: dragOperation(state.dragOperation, action),\n        stateId: stateId(state.stateId)\n    };\n}\n\n//# sourceMappingURL=index.js.map","import { createStore } from 'redux';\nimport { DragDropManagerImpl } from './classes/DragDropManagerImpl.js';\nimport { DragDropMonitorImpl } from './classes/DragDropMonitorImpl.js';\nimport { HandlerRegistryImpl } from './classes/HandlerRegistryImpl.js';\nimport { reduce } from './reducers/index.js';\nexport function createDragDropManager(backendFactory, globalContext = undefined, backendOptions = {}, debugMode = false) {\n    const store = makeStoreInstance(debugMode);\n    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));\n    const manager = new DragDropManagerImpl(store, monitor);\n    const backend = backendFactory(manager, globalContext, backendOptions);\n    manager.receiveBackend(backend);\n    return manager;\n}\nfunction makeStoreInstance(debugMode) {\n    // TODO: if we ever make a react-native version of this,\n    // we'll need to consider how to pull off dev-tooling\n    const reduxDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__;\n    return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({\n        name: 'dnd-core',\n        instanceId: 'dnd-core'\n    }));\n}\n\n//# sourceMappingURL=createDragDropManager.js.map"],"names":["isObject","input","INIT_COORDS","BEGIN_DRAG","PUBLISH_DRAG_SOURCE","HOVER","DROP","END_DRAG","setClientOffset","clientOffset","sourceClientOffset","type","payload","ResetCoordinatesAction","createBeginDrag","manager","sourceIds","options","publishSource","getSourceClientOffset","monitor","getMonitor","registry","getRegistry","dispatch","isDragging","forEach","sourceId","getSource","verifyInvariants","i","length","canDragSource","getDraggableSource","Error","verifyGetSourceClientOffsetIsFunction","item","beginDrag","verifyItemIsObject","pinSource","itemType","getSourceType","isSourcePublic","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_objectSpread","target","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","createDrop","didDrop","targetIds","getTargetIds","canDropOnTarget","reverse","getDroppableTargets","targetId","index","dropResult","getTarget","drop","undefined","verifyDropResultType","getDropResult","determineDropResult","action","createEndDrag","verifyIsDragging","getSourceId","endDrag","unpinSource","matchesType","targetType","draggedItemType","Array","isArray","some","t","createHover","targetIdsArg","verifyTargetIdsIsArray","slice","getTargetType","splice","removeNonMatchingTargetIds","getItemType","lastIndexOf","checkInvariants","hover","hoverAllTargets","createPublishDragSource","DragDropManagerImpl","receiveBackend","backend","this","getBackend","getActions","store","actions","publishDragSource","createDragDropActions","reduce","boundActions","actionCreator","args","apply","constructor","isSetUp","handleRefCountChange","shouldSetUp","getState","refCount","setup","teardown","subscribe","subtract","a","b","x","y","NONE","ALL","__IS_NONE__","__IS_ALL__","DragDropMonitorImpl","subscribeToStateChange","listener","handlerIds","prevStateId","stateId","state","currentStateId","canSkipListener","dirtyIds","itemsB","indexOf","areDirty","dirtyHandlerIds","subscribeToOffsetChange","previousState","dragOffset","nextState","canDrag","canDrop","Boolean","isDraggingSource","isOverTarget","shallow","dragOperation","getItem","getInitialClientOffset","initialClientOffset","getInitialSourceClientOffset","initialSourceClientOffset","getClientOffset","getDifferenceFromInitialOffset","ADD_SOURCE","ADD_TARGET","REMOVE_SOURCE","REMOVE_TARGET","validateType","allowArray","HandlerRole","nextUniqueId","parseRoleFromHandlerId","handlerId","SOURCE","TARGET","mapContainsValue","map","searchValue","entries","isDone","done","next","HandlerRegistryImpl","addSource","validateSourceContract","addHandler","addTarget","validateTargetContract","containsHandler","handler","dragSources","dropTargets","includePinned","isSourceId","pinnedSourceId","pinnedSource","get","isTargetId","types","removeSource","delete","removeTarget","role","id","toString","getNextHandlerId","set","Map","strictEquality","_state","prevTargetIds","result","itemsA","insertItem","has","count","push","xor","isEqual","areArraysEqual","prevInnermostTargetId","innermostTargetId","initialState","offsetA","offsetB","items","defaultValue","split","c","createDragDropManager","backendFactory","globalContext","backendOptions","debugMode","reduxDevTools","window","__REDUX_DEVTOOLS_EXTENSION__","name","instanceId","makeStoreInstance"],"sourceRoot":""}